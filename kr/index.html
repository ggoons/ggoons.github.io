<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.8.2/css/all.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css">
  <link rel="stylesheet" href="../css/tg.css" />
</head>
<body>


<div class="head">
  <h1 class="large-font"><b>Testggoon</b></h1>
  <p style="color:white;">Test data and test code generator for api server</p>
</div>

<div class="menu">
  <a href="javascript:void(0);" onclick="open_menu()">
    <i class="fa fa-bars"></i>
  </a>
</div>

<!-- The Modal -->
<div id="popupMenu" class="modal">

  <!-- Modal content -->
  <div class="modal-content">
   <ul>
    <li><a href="/en/index.html">English</a></li>
    <li><a href="#intro">What is the tg?</a></li>
    <li><a href="#api-specification">API specification</a></li>
    <li><a href="#query">Query api</a></li>
    <li><a href="#find">Find api</a></li>
    <li><a href="#mutable">Mutable api</a></li>
    <li><a href="#subTable">Component</a></li>
    <li><a href="#tg-cli">tg-cli</a></li>
    <li><a href="#tg-schema">tg schema</a></li>
    <li><a href="#ex-schema">schema extension</a></li>
    <li><a href="#fixed-testdata">Custom testdata</a></li>
    <li><a href="../samples/classicmodels.html">samples: classicmodels.json</a></li>
    <li><a href="../samples/testggoon.html">samples: testggoon.json</a></li>
   </ul>
  </div>

</div>

<div class="wrapper">

<div class="sidebar" id="sidebar">
 <ul>
  <li><a href="/en/index.html">English</a></li>
  <li><span class="caret">소개</span>
    <ul class="nested">
      <li><a href="#intro">tg 란?</a></li>
      <li><a href="#schema0">tg 스키마</a></li>
      <li><a href="#schema1">스키마 확장</a></li>
      <li><a href="#api0">API</a></li>
      <li><a href="#subTable0">Component</a></li>
	</ul>
  </li>
  <li><span class="caret">API specification</span>
    <ul class="nested">
      <li><span class="caret"><a href="#api-specification">Overview</a></span>
	    <ul class="nested">
          <li><a href="#api-columnNameCase">column name</a></li>
          <li><a href="#api-authentication">authentication</a></li>
          <li><a href="#api-login">login api</a></li>
          <li><a href="#api-paginate">paginate</a></li>
          <li><a href="#api-order-by">order by</a></li>
		</ul>
	  </li>
      <li><span class="caret"><a href="#query">Query api</a></span>
	    <ul class="nested">
          <li><a href="#query-request">request</a></li>
          <li><a href="#query-request-params">request.params</a></li>
          <li><a href="#query-response">response</a></li>
		</ul>
	  </li>
      <li><a href="#find">Find api</a></li>
      <li><span class="caret"><a href="#mutable">Mutable api</a></span>
	    <ul class="nested">
          <li><a href="#mutable-request">request</a></li>
          <li><a href="#mutable-response">response</a></li>
          <li><a href="#mutable-expects">expects</a></li>
		</ul>
	  </li>
      <li><a href="#subTable">Component</a></li>
      <li><a href="#subTable-columns">Component columns</a></li>
      <li><a href="#querySubTable">Component for Query api</a></li>
    </ul>
  </li>
  <li><span class="caret">tg-cli</span>
    <ul class="nested">
      <li><a href="#tg-cli">용어설명</a></li>
      <li><a href="#installation">설치</a></li>
      <li><span class="caret">기능</span>
        <ul class="nested">
          <li><a href="#generate">생성</a></li>
          <li><a href="#initialize">초기화</a></li>
          <li><a href="#gen-test-database">test database 생성</a></li>
          <li><a href="#run-api-server">api 서버 준비</a></li>
          <li><a href="#find-and-query-test">find and query api test</a></li>
          <li><a href="#mutable-request">mutable api test</a></li>
	    </ul>
	  </li>
	</ul>
  </li>
  <li><span class="caret">tg 스키마</span>
    <ul class="nested">
      <li><span class="caret">기본</span>
        <ul class="nested">
          <li><a href="#tg-schema">tg 스키마</a></li>
          <li><a href="#table">Table</a></li>
          <li><a href="#column">Column</a></li>
          <li><a href="#object">Object</a></li>
          <li><span class="caret">관계</span>
            <ul class="nested">
              <li><a href="#one-to-many">one-to-many</a></li>
              <li><a href="#many-to-one">many-to-one</a></li>
              <li><a href="#many-to-many">many-to-many</a></li>
              <li><a href="#one-to-one">one-to-one</a></li>
	        </ul>
		  </li>
	    </ul>
	  </li>
      <li><span class="caret">확장</span>
        <ul class="nested">
          <li><a href="#ex-schema">스키마 확장</a></li>
          <li><a href="#fixed-testdata">고유의 testdata</a></li>
	    </ul>
	  </li>
	</ul>
  </li>

  <li><span class="caret">Samples</span>
    <ul class="nested">
      <li><span class="caret">classicmodels</span>
        <ul class="nested">
          <li><a href="../samples/classicmodels.html#schema">classicmodels.json</a></li>
          <li><a href="../samples/classicmodels.html#schema-ex">schema-ex.json</a></li>
          <li><a href="../samples/classicmodels.html#api">api.json</a></li>
	    </ul>
	  </li>
      <li><span class="caret">testggoon</span>
        <ul class="nested">
          <li><a href="../samples/testggoon.html#schema">testggoon.json</a></li>
          <li><a href="../samples/testggoon.html#api">api.json</a></li>
	    </ul>
	  </li>
	</ul>
  </li>

 </ul>
</div>

<div class="content">

<div id="intro" class="container">
  <div class="row">
	  <h2>tg 란?</h2>
      <p>
		Testggoon(이하 tg 라 함) 에는 test data 생성 기능과 
		api 서버를 test 하기 위한 test code 생성 기능 등 두 가지 기능이 있습니다.
		또한 이렇게 생성된 test data 와 test code 는 강력한 연관성을 갖고 있습니다.
	  </p>

	  <h3>Test data 생성</h3>
	  <p>
		소프트웨어를 개발 하다 보면 test data 가 필요 할 때가 있습니다.
		대부분의 경우, 작은 test data 는 직접 만들어 사용 하고,
		큰 test data 는 script 를 만들어 사용 하거나
		아니면 test data 생성 tool 을 사용 하기도 합니다.
		tg 를 이용하면 작은 test data 부터 원하는 만큼 많은 양의 test data 까지
		test data 의 품질에 따라 간단히 또는 약간의 노동을 투입해서 얻을 수 있습니다.
		예를들어 사용자가 현재 mysql 을 사용하고 있고, mysql 을 위한 JDBC connetor 가
		현 classpath 에 존재 한다면 다음 한 줄 로 table 당 1000 개의 test data 를 생성할 수 있습니다.
	  </p>
	  <pre><code class="shell">
$ tg -m mysql -b databaseName -u userName -p password -t 1000
	  </code></pre>
	  이 명령으로 tg 는 test data 를 csv 형식의 파일에 생성 합니다.
	  그리고 이를 이용해서 mysql 과 mongoDB 용 test data 를 생성할 수 있는 script 를 함께 생성 합니다.
	  사용자가 mysql 과 mongoDB 이외의 DBMS 를 사용중 이라면 
	  이 두 script 를 참조하여 자신의 DBMS 에 맞게 수정하여 사용할 수 있을 것 입니다.

	  <h3>API 서버 test</h3>
	  <p>
		코딩은 재미있는 작업 이지만, test code 를 만드는 작업은 참 귀찮은 작업 입니다.
		tg 는 앞에서 생성한 test data 와 사용자가 제공한 api 정보를 바탕으로
		api 에 어떤 data 를 전달하면 어떤 data 를 응답 할것이다 라고 예측한 
		기대값 data 를 생성 합니다.
		그리고 이 기대값을 바탕으로 api 서버 test code 를 생성 합니다.
		tg 에 의해 생성되는 api 서버 test code 는 node.js 의 supertest 용 소스 파일 입니다.
		그러나 생성된 test code 는 api 서버와 HTTP 및 JSON 으로 통신 하므로 
		api 서버의 작성 언어 또는 DBMS 의 종류와 무관하게 생성된 test code 를 사용할 수 있을 것 입니다.
	  </p>


	  <!--p>
		Testggoon(이하 tg 라 함) 은 DB 스키마와 API specification 을 기반으로
		test data 와 api 서버 test code 를 자동생성하는 시스템 입니다.
		tg 가 생성하는 test data 는 csv 형식으로서 어떠한 DBMS 에서도 사용할 수 있으며,
		tg 가 생성하는 api 서버 test code 는 node.js 코드 이지만 api 서버와 통신에 HTTP 및 JSON 을
		사용 하므로 사용자의 api 서버가 어떠한 프레임워크나 언어로 작성 되었는지와 무관하게 이용할 수 있습니다.
		사용자가 tg 를 사용하기 위해서는 DB 스키마와 api specification 을 준비해야 합니다.
	  </p -->
	  <div>
	    <img class="zoom" src="../img/testggoon-concept.png" class="center"/>
	  </div>
  </div>
</div>

<div id="schema0" class="container">
  <div class="row">
	  <h2>tg 스키마</h2>
      <p>
		tg 스키마 는 DB 스키마의 JSON 표현 입니다.
		tg 는 test data 의 생성에 필요한 정보를 tg 스키마로부터 추출 합니다.
		사용자의 DBMS 가 RDB 이면, 사용자가 직접 tg 스키마를 작성할 필요는 없습니다.
		대부분의 RDB 용 DBMS 는 JDBC driver 가 있으며,
		tg 는 이를통해 tg 스키마를 자동으로 생성 합니다.
		그러나 noSQL 등 JDBC 로 연결이 불가능한 DBMS 를 사용하는 경우,
		<a href="#tg-schema">여기</a>를 참조 하여 tg스키마를 직접 작성해야 합니다.
      </p>
	  <div>
	    <img class="zoomx" src="../img/db-schema-to-tg-schema.png" class="center"/>
	  </div>
      <!--p>
		tg 스키마 는 DB 스키마의 JSON 표현 입니다.
		Test data 의 생성을 위해서는 기본적으로 tg 스키마가 필요 합니다.
		만약 목표 database 가 JDBC 와 연결된 RDB 를 사용한다면, 
		tg 스키마를 생성할 필요 없이 JDBC 와 연결 정보만 tg 에 알려주면 됩니다.
		그러나 그 이외에는 <a href="#tg-schema">여기</a>를 참조 하여 tg스키마를 직접 작성해야 합니다.
	  </p>
	  <pre><code class="json">{
  "name": "classicmodels",
  "elements": [
    {
      "table": "customers",
      "properties": [
         { "column": "customerNumber", "datatype": "int" },
         { "column": "customerName", "datatype": "string(255)" },
         { "column": "salesRepEmployeeNumber", "datatype": "int", "required": false },
        ...
      ],
      "primaryKey": { "columns": "customerNumber", "from": "user" },
      "manyToOnes": [
        { "table": "employees", "join": "salesRepEmployeeNumber = employeeNumber" }
      ],
      "oneToManies": [
        { "table": "orders", "join": "customerNumber = customerNumber" },
        { "table": "payments", "join": "customerNumber = customerNumber" }
      ],
    }
  ],
  ...
}
</code></pre -->
  </div>
</div>

<div id="schema1" class="container">
  <div class="row">
	  <h2>스키마 확장</h2>
      <p>
		tg 스키마에는 DB 스키마 수준의 정보만 포함됩니다.
		test data 를 순수한 tg 스키마에 의해 생성 한다면,
		생성되는 test data 는 table 간 연결을 위한 column 값들을 제외하면 대부분
		무의미한 무작위 숫자들 뿐 입니다.
		tg 에 의해 생성되는 test data 가 좀 더 실재 data 에 가깝도록 만들고 싶다면 추가적인 정보를
		tg 에게 제공해 주어야 합니다.
		예를 들어 이름, 주소, 이메일주소, 신용카드번호 등을 의미하는 column 값을 실재 data 처럼 생성 하고 싶은 경우,
		또는 상품 주문일자는 배송일자, 결재일자 등 보다 앞에 와야 한다와 같은 특별한 규칙이 필요한 경우가 있다면
		이것을 tg 에게 알려 주어야 합니다.
		스키마 확장에 대한 자세한 사항은 <a href="#ex-schema">여기</a> 를 참조 하십시요.
      </p>
      <!--p>
tg 스키마에는 DB 스키마 수준의 정보만 포함됩니다.
그러나 test data 를 보다 실재 data 에 가깝게 생성하기 위해서는 좀 더 추가적인 정보가 필요 합니다.
tg스키마를 확장해서 column 에 추가적인 정보를 제공할 수도 있고, 
새로운 table 관계 또는 관계에 대한 alias(as) 를 지정 또는 수정할 수도 있습니다.
스키마 확장에 대한 자세한 사항은 <a href="#ex-schema">여기</a> 를 참조 하십시요.
	  </p>
	  <pre><code class="json">{
  "elements": [
    {
      "comment": "table 에 관계를 추가할 때 아래와 같이 사용 합니다.",
      "table": "products",
      "manyToManies": [
        { "table": "orders", 
          "joinTable": { "name": "orderdetails" }
        }
      ]
    },
    {
      "comment": "table 의 column 내용을 수정할 때 아래와 같이 사용 합니다.",
      "alter": "products",
      "columns": [
        { "column": "product_image_path", "mediaType": "imagePath" },
		...
      ]
    },
    {
      "comment": "table 관계의 as 를 지정 또는 수정할 때 아래와 같이 사용 합니다.",
      "alter": "users",
      "manyToManies": [
        { "table": "users2", "as": "friends", "comment": "여기서 users2 는 이전 alias(as) 값 입니다" },
        ...
      ]
    }
  ]
}
	  </code></pre -->
  </div>
</div>

<div id="api0" class="container">
  <div class="row">
	  <h2>API specification</h2>
      <p>
		tg 가 api test 를 위한 기대값 및 test code 를 생성 하기 위해서는 api 에 대한 정보가 필요 합니다.
		tg 의 api specification 은 OAS(Open API Specification) 처럼 엄격하고 잘 정리된 그런것은 아니고
		단지 다음과 같은 정보를 어떻게 표현할지 정의한 문서 입니다.
		<ul>
		  <li>api 주소</li>
		  <li>http method</li>
		  <li>request data 구조</li>
		  <li>response data 구조</li>
		  <li>사용자 인증을 위한 api</li>
		  <li>components</li>
		  <li>response 구조에서 column 이름 규칙</li>
		  <li>mutable test 를 위한 정보</li>
		</ul>
	  </p>
	  <blockquote>
		tg 설계시 OAS(Open API Specification) 를 이용 하려고 검토 하였으나
		불행히도 OAS 는 tg 에서 요구하는 정보를 충분히 표현하지 못 하는것 같습니다.
		이에 tg 는 어쩔수 없이 tg 가 필요로 하는 모든 정보를 담을 수 있는 tg 고유의 api specification 을 개발하게 되었습니다.
		그러나 OAS 와 tg api specification 은 많은 부분 유사 하며, OAS 를 tg 용으로 또는 그 반대로 변환하는 tool 을
		tg 와 함께 제공할 계획 입니다.(not yet)
		<br/>
		현재, tg 에 의해 생성되는 파일 목록에는 OAS 를 위한 openapi.yaml 이 포함되어 있습니다.
	  </blockquote>
	  <pre><code class="json">{
    ...,
   "api": {
     ...
     "loginApis": [
       {
         ...
       },
       ...
     ]
     ...
     "queryApis": [
       {
         "request": {
           ...
         },
         "response": {
           ...
         },
       },
       ...
     ],
     ...
     "findApis": [
       {
         "request": {
           ...
         },
         "response": {
           ...
         },
       },
       ...
     ],
     ...
     "mutableApis": [
       {
         "request": {
           ...
         },
         "response": {
           ...
         },
         "expects": [
           ...
         ]
       },
       ...
     ]
   }
}
	  </code></pre>
  </div>
</div>

<div id="subTable0" class="container">
  <div class="row">
	  <h2>Components</h2>
      <p>
		Component 는 api 의 request 또는 response body 를 위한 구조 입니다.
		각 api 의 request 나 response body 정의 시 Component 를 직접 정의 할 수도 있고,
		또는 Component 를 따로 정의한 후, 이를 재 사용 할 수도 있습니다.
		Component 에는 지정된 table 의 전부 또는 일부의 columns 가 올 수 있으며
		이 외, 연관 table 들 이나 aggregation column 등 특수 column 들이 지정될 수도 있습니다.
		Component 에 대한 좀 더 자세한 사항은 <a href="#subTable">여기</a>를 참조 하십시요.
	  </p>
	  <pre><code class="json">{
    "components": [
      {
        "for": "query",
        "name": "responseFromProductList",
        "table": "products",
        "columns": [
          "productName",
          "buyPrice",
          "pLine(productlines.productLine)",
          "total(count=orderdetails)",
          "totalPrice(sum=orderdetails.priceEach)"
        ]
      }
    ],
}
	  </code></pre>
  </div>
</div>

<div id="api-specification" class="container">
  <div class="row">
	<h2>API specification</h2>
    <p>
		api 정보에는 다음과 같이 모든 api 에 적용되는 전역 항목들과
		<ul>
		  <li><a href="#api-columnNameCase">column 이름 규칙</a></li>
		  <li><a href="#api-authentication">인증토큰</a></li>
		  <li><a href="#api-login">로그인 api</a></li>
		  <li><a href="#api-paginate">응답 결과 페이징</a></li>
		  <li><a href="#api-order-by">응답 결과 정렬</a></li>
		</ul>

		다음과 같이 특정 목적을 위한 api 들이 있으며,

		<ul>
		  <li><a href="#query">queryApis</a></li>
		  <li><a href="#find">findApis</a></li>
		  <li><a href="#mutable">mutableApis</a></li>
		</ul>
		
		마지막 으로 request 와 response 구조를 위한 
		<ul>
		  <li><a href="#subTable">component</a></li>
		</ul>
		가 있습니다.
    </p>

	<div id="api-columnNameCase">
	<h3>column 이름 규칙</h3>
    <p>
		최근 API 서버를 처음부터 끝 까지 개발자가 모두 만드는 경우는 거의 없습니다.
		대부분 웹 프레임워크를 이용 하는데, 이러한 웹 프레임워크에 따라서는 column 이름을
		그대로 사용하는 경우도 있고, camel case 또는 snake case 등으로 변환하여 사용하는 
		경우도 있습니다.
		이 속성은 그러한 경우를 위한 것으로, api 서버에서 읽은 data 값을 access 하기위해
		column 은 어떤 이름 스타일을 사용 해야 하는지를 이 속성으로 지정 할 수 있습니다.
	</p>

	<h4>column 이름</h4>

	<table class="table">
	  <tr>
	    <th>속성 값</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>original(default)</td>
	    <td>
			column 이름을 그대로 사용 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>camelcase</td>
	    <td>
			column 이름을 소문자로 시작하는 camel case 로 변환 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>Camelcase</td>
	    <td>
			column 이름을 대문자로 시작하는 camel case 로 변환 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>snakecase</td>
	    <td>
			column 이름을 소문자로 시작하는 snake case 로 변환 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>Snakecase</td>
	    <td>
			column 이름을 대문자로 시작하는 snake case 로 변환 합니다.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "api": {
     ...
     "columnNameCases": {
       "column": "camelcase",
       ...
     }
   },
}
	</code></pre>

	<!--h4>관계된 table 이름</h4>

	<table class="table">
	  <tr>
	    <th>속성 값</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>original(default)</td>
	    <td>
			table 이름이나 지정된 as(alias) 이름을 그대로 사용 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>camelcase_singular 또는 singular</td>
	    <td>
			table 이름을 camel case 로 변환한 후, 단수형으로 수정하여 사용 합니다.
			주로 one-to-one 또는 many-to-one 관계의 table 이름에 사용됩니다.
		</td>
	  </tr>
	  <tr>
	    <td>camelcase_plural 또는 plural</td>
	    <td>
			table 이름을 camel case 로 변환한 후, 복수형으로 수정하여 사용 합니다.
			주로 one-to-many 또는 many-to-many 관계의 table 이름에 사용됩니다.
		</td>
	  </tr>
	  <tr>
	    <td>snakecase_singular</td>
	    <td>
			table 이름을 snake case 로 변환한 후, 단수형으로 수정하여 사용 합니다.
			주로 one-to-one 또는 many-to-one 관계의 table 이름에 사용됩니다.
		</td>
	  </tr>
	  <tr>
	    <td>snakecase_plural</td>
	    <td>
			table 이름을 snake case 로 변환한 후, 복수형으로 수정하여 사용 합니다.
			주로 one-to-many 또는 many-to-many 관계의 table 이름에 사용됩니다.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "api": {
     ...
     "columnNameCases": {
       "column": "camelcase",
       "oneToOne": "singular",
       "manyToOne": "singular",
       "oneToMany": "plural",
       "manyToMany": "plural"
     }
   },
}
	</code></pre -->
	</div>

	<div id="api-authentication">
	<h3>authentication</h3>
    <p>
		대부분의 api 서버는 인가된 사용자의 접근만 허용 합니다.
		사용자 인증에는 session 방식과 token 방식이 있는데,
		이곳에서 이와 관련된 정보를 tg 에 제공할 수 있습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>by</td>
	    <td>
			사용자 인증 방식을 지정하는 속성으로 jwt 와 session 중 하나를 선택할 수 있습니다.
			<blockquote>
				현재는 오직 jwt 만 가능 합니다.
			</blockquote>
		</td>
	  </tr>
	  <tr>
	    <td>headers</td>
	    <td>
			인증 정보가 http header 에 어떤 형식으로 전달 되는지 이 속성으로 지정할 수 있습니다.
			아래의 예 에서 보는바와 같이, '${jwt}' 는 실재 token 이 있어야 할 위치를 표시 합니다.
		</td>
	  </tr>
	</table>

	<pre><code class="json">{
   "api": {
     ...
     "authentication": {
       "by": "jwt",
       "headers": [
         { "key": "Authorization", "value": "Bearer ${jwt}" }
       ]
     },
   }
}
	</code></pre>
	</div>

	<div id="api-login">
	<h3>login api</h3>
    <p>
		사용자 인증을 위한 api 주소 및 인증을 위한 request 와 response 정보를 여기서 하나이상 지정할 수 있습니다.
	</p>

	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>url</td>
	    <td>
			사용자 인증을 위한 주소 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>roles</td>
	    <td>
			이 주소에 의해 인가된 사용자가 가질 수 있는 모든 권한들을 콤마로 구분하여 나열 하십시요.
			api 가 특정 권한을 필요로 할 때, tg 는 그 권한을 획득할 수 있는 login api 를 이 속성 값을 보고
			찿습니다.
		</td>
	  </tr>
	  <tr>
	    <td>method</td>
	    <td>
			HTTP method 로 get 과 post 가 있으며 default 는 post 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>request</td>
	    <td>
			사용자 인증을 위한 request body 의 구조를 의미하며 username 을 위한 key 와 password 를 위한 key 를
			여기서 지정 하십시요.
		</td>
	  </tr>
	  <tr>
	    <td>response</td>
	    <td>
			사용자 인증에 대한 response body 구조 중 token 의 위치를 여기서 지정 하십시요.
		</td>
	  </tr>
	</table>

	<pre><code class="json">{
   "api": {
     ...
     "loginApis": [
       {
         "url": "/jwt/customer",
         "roles": "ROLE_CUSTOMER, ROLE_VIP_CUSTOMER",
         "method": "post",
         "request": {
           "username": "username",
           "password": "password",
         },
         "response": {
           "tokenPath": "jwt.token",
           "comment": "이 경우는 response.body.jwt.token 에 token 이 들어있는 경우 입니다.",
         }
       }
     ]
     ...
     "queryApis": [
       {
         "request": {
           "url": "/customers/show",
           "accessRoles": "ROLE_CUSTOMER"
         },
       }
     ]
   }
}
	</code></pre>
	</div>

	<div id="api-paginate">
	<h3>paginate</h3>
    <p>
		api 서버의 query api 가 결과를 page 단위로 나누어서 응답 하는 경우 이와 관련된 정보를 여기서 지정할 수 있습니다.
	</p>

	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>keyToPageNo</td>
	    <td>
			현 query 대상 page number 를 api 서버에 전달 할 때 사용하는 key 를
			여기서 지정 하십시요. default 는 'page-no' 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>keyToNumRows</td>
	    <td>
			한 page 당 row 수 를 지정 할 때 사용하는 key 를
			여기서 지정 하십시요. default 는 'num-rows' 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>numRows</td>
	    <td>
			page 당 row 수를 number 로 지정 하십시요.
			만약 이 수 가 하나 이상이면 배열로 지정 하십시요.
		</td>
	  </tr>
	</table>

	<pre><code class="json">{
   "api": {
     ...
     "paginate": {
       "keyToPageNo": "page-no",
       "keyToNumRows": "num-rows",
       "numRows": 20
     },
   }
}
	</code></pre>
	</div>

	<div id="api-order-by">
	<h3>order by</h3>
    <p>
		query 결과를 특정 column 값으로 정렬할 때, 이 정보를 api 서버에 전달해야 하는데, 
		이와 관련된 정보를 여기서 지정할 수 있습니다.
	</p>

	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>in</td>
	    <td>
			'order by' 정보가 어디로 전달될 지 결정 합니다. 
			path, query, header 또는 body 중 하나의 값을 가질 수 있습니다.
		</td>
	  </tr>
	  <tr>
	    <td>key</td>
	    <td>
			'order by' 를 위한 key 이름을 여기서 지정 하십시요.
			default 는 'order-by' 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>value</td>
	    <td>
			key 에 대한 값의 형식을 의미 합니다.
			default 는 '&lt;c&gt; &lt;order&gt;' 이며 여기서 &lt;c&gt; 는 column 이름을 의미하고,
			&lt;order&gt; 는 아래의 order 속성 값을 의미 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>order</td>
	    <td>
			정렬에는 오름차순(asc) 과 내림차순(desc) 이 있습니다. 여기서 각각을 의미하는 정확한 단어를 지정 하십시요.
			default 로 오름차순 은 'asc' 이고, 내림차순 은 'desc' 입니다.
		</td>
	  </tr>
	</table>

	<pre><code class="json">{
   "api": {
     ...
     "orderBy": {
       "in": "query",
       "key": "order-by",
       "value": "&lt;c&gt; &lt;order&gt;",
       "order": {
         "asc": "asc",
         "desc": "desc"
       },
     },
   }
}
	</code></pre>
	</div>

  </div>
</div>

<div id="query" class="container">
  <div class="row">
	  <h2>Query api</h2>
      <p>
api 서버의 test 를 위한 test code 생성을 위해 api 에 대한 정보가 필요 합니다.
하나 이상의 rows 를 return 하는 api 를 query api 라고 합니다.
query api 를 위한 구조에는 request 와 response 가 있습니다.
	  </p>

    <div id="query-request">
	  <h3>request</h3>
		query api 의 request 에는 다음과 같은 요소가 있습니다.
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>url</td>
	    <td>
			api 의 주소를 의미 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>method</td>
	    <td>
			api 의 HTTP method 를 의미 합니다. query api 에서는 default 가 "get" 입니다.
		</td>
	  </tr>
	  <tr>
	    <td>accessRoles</td>
	    <td>
			api 가 특정 권한을 가진 사용자들만 이용할 수 있는 경우, 허가된 사용자 권한들을 이 속성 값에 콤마로 구분하여 나열 하십시요.
			<pre><code class="json">{
  "request": {
    "url": "/customers/list",
    "accessRoles": "CUSTOMER_MANAGER, ADMIN"
    ...
  }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>concurrentRequests</td>
	    <td>
			query test 를 동시에 진행할 인스턴스 수 를 지정 하십시요.
			여기서 지정한 수 만큼 test request 가 동시에 api 서버에 전달 됩니다.
			<pre><code class="json">{
  "request": {
    "url": "/customers/list",
    "concurrentRequests": 10,
    ...
  }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>paginate</td>
	    <td>
			query 결과가 page 단위로 return 된다면 true 로 지정 하십시요.
			이 속성값이 true 가 되면, test code 는 page 단위로 진행 되도록 생성 됩니다.
			<pre><code class="json">{
  "request": {
    "url": "/customers/list",
    "paginate": true,
    ...
  }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>params</td>
	    <td>
			api 의 허용 가능한 인수 목록으로서 아래에서 좀 더 자세히 설명 됩니다.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
    "elements": [
      {
        "table": "customers",
        "queryApis": [
          {
            "request": {
              "url": "/customers/list",
              "method": "get",
              "paginate": true,
              "params": [
                ...
              ]
            }
          },
          ...
        ]
      }
}
	</code></pre>

    <div id="query-request-params">
	  <h4>request params</h4>
	  <p>
이것은 api 에 전달 가능한 모든 인수를 나열 한 것 입니다.
api 서버는 여기에 나열된 인수들의 전부 또는 일부를 입력받아 그에따른 적절한 결과를 return 할것으로 가정 합니다.
각 인수에는 다음과 같은 요소가 있습니다.
	  </p>

	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>name</td>
	    <td>
			api 서버가 기대하는 인수이름을 정확히 여기에 지정해야 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>column</td>
	    <td>
			이 인수가 table column 을 의미하고, 앞의 name 항목이 column 이름과 같지 않을 때, 
			정확한 column 이름을 여기에서 지정 해야 합니다.
			column 이 query table column 이 아닌 경우, 다음과 같이 그 경로를 지정해 줄 수 있습니다.
			단, 이 경우, 각 table 들은 적절한 관계를 갖고 있어야 합니다.
			<pre><code class="json">{
    "elements": [
      {
        "table": "customers",
        "queryApis": [
          {
            "request": {
              "url": "/customers/statistics",
              "method": "get",
              "params": [
                { "name": "paymentDate", "column": "customers.payments.paymentDate", 
                  "in": "query", "op": "between" 
                }
              ]
            }
          },
          ...
        ]
      }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>in</td>
	    <td>
			이 속성은 인수가 어디로 전달 되어야 하는지를 지정 합니다. 
			인수의 전달 위치는 다음과 같습니다.
			<ul>
				<li>path
					<p>url 의 path 부분으로 전달 됩니다.
					</p>
				</li>
				<li>query
					<p>url 의 query 부분으로 전달 됩니다.
					</p>
				</li>
				<li>head
					<p>request 의 head 부분으로 전달 됩니다.
					</p>
				</li>
			</ul>
		</td>
	  </tr>
	  <tr>
	    <td>op</td>
	    <td>
			api 서버가 이 param 값을 query 에 반영할 때 사용하는 연산자를 의미하며 사용 가능한 연산자는 다음과 같습니다.
			<blockquote>
				아래의 연산자들 이외의 연산자가 사용된 경우에는 아직 tg 에서 지원하지 않고 있습니다.
				아래의 연산자들로 사용자의 api 서버의 연산동작을 충분히 표현 하지 못 하다면 
				<a href="#query-response-filter">커스텀 필터</a> 기능을 사용 해야 합니다.
				<ul>
					<li>관계 연산자(=, !=, &lt;, &lt;=, &gt;, &gt;=)</li>
					<li>like, fast like</li>
					<li>in</li>
					<li>between</li>
				</ul>
				like 연산자는 SQL 의 "LIKE '%val%'" 연산을 의미하며 
				fast like 연산자는 SQL 의 "LIKE 'val%'" 연산을 의미 합니다.
				알려진 바와 같이 전자는 table scan 이고 후자는 index scan 입니다.
			</blockquote>
		</td>
	  </tr>
	  <tr>
	    <td>required</td>
	    <td>
			이 param 값이 request 에 항상 포함 되어야 하면 이 속성을 true 로 지정 하십시요.
			이 속성이 true 이면 이 param 값은 모든 test params 조합에 항상 포함 됩니다.
			<pre><code class="json">{
  ...
  "params": [
     { "name": "productName", "in": "query", "op": "fast like", "required": true },
	 ...
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>class</td>
	    <td>
			몇몇 params 는 request 에 모두 같이 존재 하거나 모두 같이 없어야 합니다.
			이 속성은 그런 경우 사용 합니다.
			즉, 같은 class 에 속한 params 들은 언제나 같이 request 에 포함 되거나 또는 모두 포함되지 않습니다.
			<blockquote>
				그러나 이 속성은 required 속성 보다 우선순위가 낮습니다.
				따라서 required 속성이 true 이면 class 속성은 무시 됩니다.
			</blockquote>
			<pre><code class="json">{
  ...
  "params": [
     { "name": "productCode", "in": "query", "op": "=", "class": "fk" },
     { "name": "productName", "in": "query", "op": "=", "class": "fk" },
	 ...
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>value</td>
	    <td>
			param 값이 특정 상수 값으로 고정 되어야 하는 경우 여기서 그 상수값을 지정할 수 있습니다.
			<pre><code class="json">{
  ...
  "params": [
     { "name": "language", "in": "query", "op": "=", "value": "en" },
	 ...
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>default</td>
	    <td>
			value 속성과 함께 default 속성이 사용 된다면 api 서버에 이 param 은 전달되지 않습니다.
			그러나 api 서버가 return 하는 결과에는 이 param 이 의미하는 key column 의 값이 
			속성 value 의 값으로 지정된 값이 반영 되었다고 가정 합니다.
			따라서 이 경우, tg 는 api 서버의 test 를 위한 기대값 생산에 속성 value 에 주어진 값을 사용하게 됩니다.
			<pre><code class="json">{
  ...
  "params": [
     { "name": "language", "in": "query", "op": "=", "value": "en", "default": true },
	 ...
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>select</td>
	    <td>
			이 속성은 미리 정 해진 소수의 값들 중 하나를 사용자가 선택하면 그 값에 해당하는 특정 값이 query 결과에
			영향을 주는 경우 사용 됩니다.
			<pre><code class="json">{
  ...
  "params": [
     { 
       "name": "order_date", "in": "query", "op": "between",
       "select": {
         "1 weeks": ["-7d", "0"],
         "3 weeks": ["-21d", "0"],
         "1 months": ["-1m", "0"]
       }
     },
	 ...
}
			</code></pre>
			위의 예는 최근 1주, 3주 또는 한달 간 주문 내역에 대한 query 를 가정한 경우 입니다.
			여기서 key 값들은 사용자가 선택할 수 있는 값들로서 선택된 값은 api 서버에 전달 될것입니다.
			그리고 data 값 들은 key 값이 전달 되었을 때 query 에 반영하는 값을 의미 합니다.
			예를들어 위 에서 사용자가 '3 weeks' 를 선택한 경우를 가정하면 api 서버에는 'order_date=3 weeks' 가 전달되고
			이에 대한 기대값 계산에는 'order_date between 21.days.ago and today' 가 사용 될 것입니다.
		</td>
	  </tr>
	  <tr>
	    <td>table</td>
	    <td>
			param 값이 many-to-many table join 에 사용된 경우, many-to-many table 이름을 이 속성으로 지정해야 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>reverse</td>
	    <td>
			param 값이 같은 table 간 many-to-many join 에 사용된 경우, join 방향을 이 속성으로 조절할 수 있습니다.
			예를들어 다음은 주어진 customer 를 friend 로 선택한 모든 customer 가 query 되고,
			<pre><code class="json">{
  ...
  "params": [
     { 
       "name": "friends4customer", "table": "friends", "in": "query", 
       "op": "join"
     },
	 ...
}
			</code></pre>
			다음은 주어진 customer 가 friend 로 선택한 모든 customer 가 query 된다고 가정 합니다.
			<pre><code class="json">{
  ...
  "params": [
     { 
       "name": "friendsOfCustomer", "table": "friends", "in": "query", 
       "op": "join", "reverse": true
     },
	 ...
}
			</code></pre>
		</td>
	  </tr>
	</table>

    <p>
		경우에 따라서는 tg 에서 준비된 모든 방법을 다 사용 하더라도 api 서버의 결과를 표현 하는데 충분하지 않을 수 있습니다.
		이 경우, 사용자 고유의 filter 를 사용하여 api 서버가 return 해야 하는 기대값을 사용자가 원하는 대로 조절할 수 있습니다.
		<a href="#query-response-filter">response.filter</a> 참조
    </p>
	</div> <!-- for query-request-params -->
	</div> <!-- for query-request -->

    <div id="query-response">
	  <h3>response</h3>
    <p>
		query api 의 응답 구조를 여기서 정의 합니다. query api 의 response 에는 다음과 같은 요소가 있습니다.
    </p>

	  <h4>response.body</h4>
		<p>
			body 가 특정 table 을 의미하면 해당 table 이름을 지정 하십시요.
		</p>
		<pre><code class="json">{
    "body": "tableName"
}
		</code></pre>
			또는 body 가 특정 <a href="#querySubTable">Component</a> 를 재 사용 하면 
			해당 Component 이름을 지정 하십시요.
		<pre><code class="json">{
    "body": "componentName"
}
		</code></pre>
		<p>
			사실 response body 는 이름이 자동으로 부여되는 
			<a href="#querySubTable">Component</a> 입니다.
			한 가지 차이점은 다음과 같이 'columns' key 없이 직접
			columns 를 지정할 수 있다는 점 입니다.
		</p>
		<pre><code class="json">{
  "body": {
    "cname": ".",
    "anyname": "columnName",
	...
  }
}
		</code></pre>
		<p>
			위의 경우와 같이 'columns' 속성이 없으면 모든 key-value 쌍은 columns 로 인식 합니다.
			그러나 <a href="#querySubTable">Component</a> 의 모든 속성을 이용 하려면 다음과 같이
			'columns' 속성을 사용해야 합니다.
		</p>
		<pre><code class="json">{
    "body": {
      "table": "customers",
      "paginate": true,
      "orderableColumns": "city",
      "columns": {
        "cname": ".",
        "anyname": "columnName",
        ...
      },
    }
}
		</code></pre>


    <div id="query-response-filter">
	  <h4>response.filter</h4>
		<p>
			api 의 test 를 위해 tg 에 의해 생성된 기대값이 적절치 않은경우, 
			tg 에 의해 생성된 기대값을 사용자 코드로 filtering 할 수 있습니다.
			filter 는 api 서버로 부터 값을 읽은 후, tg 에서 준비한 기대값과 assert 하기 전
			기대값을 사용자가 수정할 수 있도록 허용 합니다. 
			즉, 사용자가 설치한 filter 를 통과한 기대값과 실재 api 서버의 응답값을 비교 합니다.
			<br/>
			filter 에는 다음과 같은 속성이 있습니다.
		</p>

		<img class="zoom" src="../img/response.filter.png" class="center"/>
		<br/><br/>

		<table class="table">
			<tr>
				<th>속성 값</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>name</td>
				<td>
					filter 의 이름으로, 모든 filter 들 중 유일한 이름 이어야 합니다.
				</td>
			</tr>
			<tr>
				<td>file</td>
				<td>
					api specification file 의 위치에서 filter 의 상대 위치를 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>functionName</td>
				<td>
					file 에서 filter 함수의 이름을 지정 하십시요.
				</td>
			</tr>
		</table>
		<pre><code class="json">{
    "filter": {
      "name": "customerPayment",
      "file": "./js/customer_payments.js",
      "functionName": "filter4customer_payments"
    }
}
		</code></pre>
	</div> <!-- for query-response-filter -->
	</div> <!-- for query-response -->

  </div>
</div>

<div id="find" class="container">
  <div class="row">
	  <h2>find api</h2>
		<p>
			find api 는 특정 table 의 한 row 만 읽어 오는 api 를 의미 하며 전달되는 인수는 주로 primary key 입니다.
			find api 의 모든 요소는 query api 와 동일 하므로 <a href="#query">여기</a> 를 참조 하십시요.
		</p>
		<pre><code class="json">{  ...
          "table": "customers",
          "findApis": [
            {
              "request": {
                "url": "/customers/find/:customerNumber",
                "accessRoles": "ROLE_CUSTOMER, ROLE_ADMIN",
                "params": [
                  { "name": "customerNumber", "in": "path", "op":"=" }
                ]
              },
              "response": {
                "body": "customers"
              }
            }
          ],
  ...
}
		</code></pre>
  </div>
</div>

<div id="mutable" class="container">
  <div class="row">
	  <h2>mutable api</h2>
		<p>
			mutable api 는 create, update 또는 delete 와 같은 DB 에 변화를 일으키는 api 를 의미 합니다.
			mutable api 에는 다음과 같은 종류의 요소가 있습니다.
		</p>

	<div id="mutable-request">
	  <h3>request</h3>
		<p>
			mutable api 의 request 에는 다음과 같은 요소가 있습니다.
		</p>

		<table class="table">
			<tr>
				<th>속성 값</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>testdataUrl</td>
				<td>
					이 항목은 다른 mutable test 에 사용된 test data 를 재사용 하기 위해 사용 됩니다.
					예를들어 인터넷 쇼핑몰의 상품 주문은 여러 과정을 거치는데, 그 시작은 주문 table 의 생성 입니다.
					이 후, 배송 이나 구매결정 또는 반품등은 모두 주문 table 을 대상으로 추가적인 작업을 합니다.
					이와같이 추가적인 작업을 하기 전, test data 를 공유 하는데 이 항목을 이용 합니다.
					<pre><code class="json">{
  "request": {
    "testdataUrl": "/order_products/save",
    "url": "/order_products/paymented/:id", 
    "params": [
      { "name": "id", "in": "path", "value": "${.id}"}
    ],
    ...
}
					</code></pre>
					위의 예 에서 url 의 :id 부분은 params 의 ${.id} 값으로 대체 되는 데 
					이 값은 "/order_products/save" 에 사용된 order_products.id 가 됩니다.
				</td>
			</tr>
			<tr>
				<td>url</td>
				<td>
					api 의 주소를 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>method</td>
				<td>
					api 의 HTTP method 를 의미 합니다. mutable api 에서는 default 가 "post" 입니다.
				</td>
			</tr>
			<tr>
				<td>numOfTest</td>
				<td>
					이것은 하나의 api 로 create 와 update 를 함께 test 하는 경우를 위한 것입니다.
					따라서 여기서 지정하는 수 만큼 이 api 를 위한 테스트 데이터가 동일한 primary key 로 생성되며, 
					첫번째 데이터는 create 용도로 사용되고, 그 이후의 데이터들은 update 용도로 사용 됩니다.
				</td>
			</tr>
			<tr>
				<td>accessRoles</td>
				<td>
					query api 의 request 에 있는 accessRoles 와 동일 한 의미 입니다. 
					<a href="#query-request">여기</a> 를 참조 하십시요.
				</td>
			</tr>
			<tr>
				<td>params</td>
				<td>
					mutable api 에서도 params 를 사용할 수는 있지만 query api 만큼 큰 의미는 없습니다.
					단지 추가적인 인수의 전달 목적을 위해 사용할 수 있습니다.
				</td>
			</tr>
			<tr>
				<td>body</td>
				<td>
					request body 를 의미하며 table 이름을 지정 하거나 또는 
					고유의 columns 및 연관 table 구조를 직접 정의할 수 있습니다.
					이 부분은 기본적으로 query api 의 response body 와 유사 하므로 
					<a href="#query-response">여기</a> 를 참조 하십시요.
				</td>
			</tr>
		</table>

	</div> <!-- for mutable-request -->

	<div id="mutable-response">
	  <h3>response</h3>
		<p>
			response 는 body 를 가지며, 이것 또한 기본적으로 query api 의 
			response body 와 유사 하므로 <a href="#query-response">여기</a> 를 참조 하십시요.
			그러나 추가적으로 mutable api 의 response body 에는 단순히 request 의 
			성공이나 실패만을 위해 다음과 같은 형식의 지정이 가능 합니다.
		</p>
		<pre><code class="json">{
  "body": "resultPath: result, 'ok', 'fail'"
}
		</code></pre>
			body 가 "resultPath:" 로 시작하고 콤마로 구분된 3개의 항목이 지정되면 tg 는 이를 다음과 같이 해석 합니다.
		<table class="table">
			<tr>
				<th>위치</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>First</td>
				<td>
					HTTP response body 에서 request 결과를 알리는 값의 위치를 
					javascript 형식으로 표현한 것.
					즉, 결과가 하나 이상의 Object 로 wraping 되었다면 그 path 를 
					점(.) 으로 구분하여 지정한 것으로 인식 합니다.
				</td>
			</tr>
			<tr>
				<td>Second</td>
				<td>
					성공을 의미하는 값.
				</td>
			</tr>
			<tr>
				<td>Third</td>
				<td>
					실패를 의미하는 값.
				</td>
			</tr>
		</table>
		<p>
			이 정보를 바탕으로 tg 는 mutable api 에 대한 request 가 성공 했는지, 
			아니면 실패 했는지 판단 합니다.
		</p>
		<blockquote>
			tg 는 mutable api 의 response body 를 비교대상으로 취급하지 않습니다.
			response 는 말 그대로 server 의 응답일 뿐, tg 는 server 의 응답이 아니라 
			database 의 현 상태를 검증 대상으로 취급 합니다.
		</blockquote>

	</div> <!-- for mutable-response -->

	<div id="mutable-expects">
	  <h3>expects</h3>
      <p>
		이 정보는 mutable api 가 수행 되었을 때, 변화 한 DB 의 상태를 의미 합니다.
		즉, tg 는 mutable api 서버의 test 를 위해 request body 로 지정된 구조에 맞게 
		임의의 data 를 생성, api 서버에 전달한 후,
		response 가 정상이면, expects 에서 지정한 table 들을 하나씩 읽어가며 검증 합니다.
		<br/><br/>
		expects 는 배열로 지정 되어야 하며, 각 원소는 다음과 같은 요소를 갖습니다.
      </p>

		<table class="table">
			<tr>
				<th>속성 값</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>action</td>
				<td>
					mutable action 을 의미 하며 create, update 또는 delete 를 가질 수 있습니다.
				</td>
			</tr>
			<tr>
				<td>$ref</td>
				<td>
					action 대상이 된 table 이름을 지정 하거나 또는 "${request.body}" 
					에 의해 request body 구조를 가리킬 수 있습니다.
					<pre><code class="json">{
  "$ref": "tableName"
}
					</code></pre>
					<pre><code class="json">{
  "$ref": "${request.body}"
}
					</code></pre>
				</td>
			</tr>
			<tr>
				<td>columns</td>
				<td>
					$ref 가 table 인 경우, table 의 특정 column 과 기대값을 지정 합니다.
					기대값은 상수가 될 수도 있고, 다음 예와 같이 request body 의 특정 column 값 일수도 있습니다.
				</td>
			</tr>
			<tr>
				<td>queryRequests</td>
				<td>
					여기서 mutable action 에 의해 변화된 table 을 어떻게 읽을 것인지 지정 해야 합니다.
					형식은 <b>"tableName": "url"</b> 입니다.
					예를들어 다음과 같이 지정된 경우에 tg 는 먼저 api 서버에 request 를 보낸 후,
					table order_products 의 state column 값이 "delibery" 로 수정 되었는지,
					그리고 carrier 와 tracking_number column 값이 
					request body 의 그 값과 같은지 검사하게 됩니다.
					<pre><code class="json">{
  "expects": [
    {
      "action": "update",
      "$ref": "order_products",
      "columns": {
        "state": "'delibery'",
        "carrier": "${request.body.carrier}",
        "tracking_number": "${request.body.tracking_number}"
      },
      "queryRequests": {
        "order_products": "/order_products/find/${.id}"
      }
    }
  ]
}
					</code></pre>
				</td>
			</tr>
			<tr>
				<td></td>
				<td>
				</td>
			</tr>
		</table>
	</div> <!-- for mutable-expects -->
  </div>
</div>

<div id="subTable" class="container">
  <div class="row">
	<h2>Component</h2>
 		<p>
			api 의 request 또는 response body 가 정확히 DB table 과 같은 구조를 갖는 경우도 있지만
			그렇지 않은 경우도 많습니다.
			이와같이 DB table 이외에 새로운 구조가 필요할 때 Component 가 사용 됩니다.
			사용자는 Component 를 통해 스키마에 없는 새로운 구조를 정의할 수 있습니다.
			Component 에는 일반 Component 와 Query api 에서만 사용 가능한 Query api 전용 Component 가 있습니다.
			먼저 일반적인 Component 에 대해 알아본 후, Query api 전용 Component 에 대해 언급 하겠습니다.
		</p>
		<pre><code class="json">{
  "components": [
    {
      "name": "ResponseForProductFind",
      "table": "products",
      "columns": {
        "cname": ".",
        "anyname": "columnName",
      }
	...
    }
  ]
}
		</code></pre>
		<p>
			위의 예 에서 보는 바와 같이 Component 는 다음과 같은 구성요소를 갖습니다.
		</p>
		
		<table class="table">
			<tr>
				<th>속성 값</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>name</td>
				<td>
					이 속성은 Component 의 이름을 의미 합니다.
					반드시 다른 table 이름이나 Component 이름과 중복되지 않아야 합니다.
				</td>
			</tr>
			<tr>
				<td>table</td>
				<td>
					이 속성은 Component 의 기반 table 이름을 의미 합니다.
					대부분 이 table 은 아래의 columns 에 주어진 column 들이 속한 table 을
					의미 합니다. 만약 columns 속성에 하나 이상의 table column 이 필요 하다면
					그 중 가장 중심이 되는 table 이름을 이 속성에 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>columns</td>
				<td>
					이 속성은 실재 Component 의 구조를 의미 합니다.
				</td>
			</tr>
		</table>

    <div id="subTable-columns">
	  <h2>columns</h2>
 		<p>
			Component 의 columns 속성에서 실재 Component 의 구조를 정의할 수 있습니다.
			이 속성은 String, Array 또는 Object type 으로 그 값을 지정할 수 있는데
			먼저 가장 간편한 String type 을 살펴보면, table 의 모든 column 을 지정 하려면
 		</p>
		<pre><code class="json">{
      "columns": "*"
}
		</code></pre>

			또는 특정 column 이름들만 지정할 수도 있습니다.
		<pre><code class="json">{
      "columns": "customerNumber, customerName, city, country"
}
		</code></pre>

			또는 다른 table column 도 연결정보와 함께 지정할 수 있습니다.
		<pre><code class="json">{
      "columns":
        "sellerName(employees.lastName), officeCity(employees.offices.city)"
}
		</code></pre>
			위의 예 에서 'sellerName' 과 'officeCity' 는 api 서버가 출력 하거나 기대하는
			값 이어야 합니다. (SQL 에서는 as 로 지정된 column 일 수 있습니다.)
			<br/><br/>

			aggregation column 도 지정할 수 있습니다.
			아래의 예 에서 countOfPayments 와 amounts 는 
			body 로 전달되는 aggregation column 이름을 의미하며
			'count=payments' 는 payments table 에 대한 count 값을,
			'sum=payments.amount' 는 
			payments table 의 amount column 에 대한 sum 값을 의미 합니다.
		<pre><code class="json">{
      "columns":
        "countOfPayments(count=payments), amounts(sum=payments.amount)"
}
		</code></pre>

			또는 하나 이상의 column 들 값을 통합하는 concat column 도 지정할 수 있습니다.
		<pre><code class="json">{
      "columns": "customerNumber, name(concat=firstName, ' ', lastName)"
}
		</code></pre>

		또는 사용자 정의 column 도 지정할 수 있습니다.
		<pre><code class="json">{
      "columns":
        "customizedName(function=../lib/custom.custom_name)"
}</code></pre>

		위의 예 에서 '../lib/custom' 는 tg 스키마가 있는 위치에서의 상대 위치를 의미하며
		확장자는 .rb(ruby source file) 이어야 합니다. 즉 이 경우 tg 는 
		'../lib/custom.rb' 파일을 찾습니다.
		이 파일은 그 경로와 module 구성이 관례를 따라야 하는데 이 경우 custom.rb 는
		다음과 같이 구성 되어야 합니다.
		<pre><code class="ruby">
module Lib
  class Custom
    class &lt;&lt; self
      def custom_name(map, t, rownum)
         ...
      end
    end
  end
 end
end
		</code></pre>

		함수에 전달되는 매개변수는 고정되어 있는데 이들의 이름및 의미는 다음과 같습니다.
		<table class="table">
			<tr>
				<th>인수</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>map</td>
				<td>
					testdata 전체를 의미 합니다.
					특정 table 의 testdata 는 table.name 으로 접근 가능 합니다.
				</td>
			</tr>
			<tr>
				<td>t</td>
				<td>
					현 Component 의 table 입니다.
					이 table 을 위한 testdata 를 구하려면 다음과 같이 하십시요.
					<pre><code class="ruby">
    rows = map[t.name]
					</code></pre>
				</td>
			</tr>
			<tr>
				<td>rownum</td>
				<td>
					현 table, 즉 속성 t 의 특정 rownum 입니다.
					이 table 의 특정 row 를 구하려면 다음과 같이 하십시요.
					<pre><code class="ruby">
    rows = map[t.name]
    row = rows.at(rownum)
					</code></pre>
					이제 특정 table 의 특정 row 까지 구했으니
					각 column 값은 해당 column 이름으로 다음과 같이 구할 수 있습니다.
					<pre><code class="ruby">
    rows = map[t.name]
    row = rows.at(rownum)
    firstName = row['first_name']
    lastName = row['last_name']
    # concat first_name and last_name
    firstName + ' ' + lastName
					</code></pre>
				</td>
			</tr>
		</table>

		Array type 도 비슷하게 다음과 같이 이용할 수 있습니다.
		<pre><code class="json">{
    ...
      "columns": [
        "customerNumber",
        "customerName",
        "city",
        "country",
        "countOfPayments(count=payments)",
        "amounts(sum=payments.amount)"
        "name(concat=contactFirstName, ' ', contactLastName)",
        "sellerName(employees.lastName)",
        "officeCity(employees.offices.city)",
        "customizedName(function=../lib/custom.custom_name)"
      ]
    ...
}
		</code></pre>
		
		Object type 은 가장 강력한 기능 으로서 거의 모든 구조를 정의할 수 있습니다.
		<pre><code class="json">{
    ...
      "columns": {
        "customerNumber": ".",
        "customerName": ".",
        "city": ".",
        "country": ".",
        "countOfPayments: "count=payments",
        "amounts: "sum=payments.amount"
        "name: "concat=contactFirstName, ' ', contactLastName",
        "sellerName: "employees.lastName",
        "officeCity": "employees.offices.city",
        "customizedName: "function=../lib/custom.custom_name"
      }
    ...
}
		</code></pre>
		위에서 보는바와 같이 좌측의 key 부분에 api 서버가 기대하는 이름이 와야 하고, 
		우측의 value 부분에 table 의 column 이름이 와야 합니다.
		만약 좌측 이름이 정확히 column 이름을 의미하면 우측에는 "." 만 지정 하십시요.
		그러나 좌측 이름이 정확한 column 이름이 아니라면, 우측에 정확한 column 이름을 지정 하십시요.
		추가적으로 Object 에서는 다음과 같이 임의의 구조를 지정할 수 있습니다.

		<pre><code class="json">{
    ...
      "columns": {
          "customerNumber": ".",
          "__xtra__": {
            "Amount": "sum=payments.amount"
          },
          "payments": { 
            "paymentDate": "paymentDate" 
          }
      }
    ...
}
		</code></pre>
		위의 예 에서, "__ xtra __" 는 table 이 아닌 
		임의의 구조가 body 에 포함된 것을 표현한 것이고,
		payments 는 payments table 이 포함된 경우를 표현한 것 입니다.
		이와같이 새로운 Object 를 유도하는 key 값이 table 이름이면, Object 를 
		해당 table 의 columns 로 인식하고,
		table 이름이 아니면, 현 table 의 columns 로 인식 합니다.
		만약 table 이름과 다른 이름으로 table 을 표현 하려면 다음과 같이 
		someName(table=tableName) 의 형식을 사용 하십시요.
		
		<pre><code class="json">{
    ...
      "columns": {
        "customerNumber": ".",
        "someNameOfPayment(table=payments)": { 
          "paymentDate": "paymentDate" 
        }
      }
    ...
}
		</code></pre>
   </div>
 </div>
</div>


<div id="querySubTable" class="container">
  <div class="row">
	<h2>Component for Query api</h2>
    <p>
		Component 지정 시, "for" 속성을 "query" 로 지정하면 query api 를 위한 Component 가 됩니다.
    </p>
	<pre><code class="json">{
  ...
    "components": [
      {
        "for": "query",
        "name": "responseFromProductList",
        "table": "products",
        "columns": [
          "productName",
          "buyPrice",
          "pLine(productlines.productLine)",
          "total(count=orderdetails)",
          "totalPrice(sum=orderdetails.priceEach)"
        ]
      },
      ...
    ]
  ...
}
	</code></pre>
    <p>
		Query api 를 위한 Component 는 일반 <a href="#subTable">Component</a> 의 기능
		이 외에 다음과 같은 몆가지 기능을 추가적으로 갖고 있습니다.
    </p>
		<table class="table">
			<tr>
				<th>속성 값</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>paginate</td>
				<td>
					query 결과가 page 단위로 응답할 때 이 속성을 true 로 지정 하십시요.
					그러면 tg 는 하나 이상의 page 에 대한 query 와 assert 를 진행 하도록 코드를 생성할 것 입니다.
					<pre><code class="json">{
  ...
        "paginate": true,
  ...
}					</code></pre>
				</td>
			</tr>
			<tr>
				<td>groupBy</td>
				<td>
					group by columns 를 하나이상 지정할 수 있습니다.
					이 속성이 지정되면 tg 는 여기서 지정된 column 값으로 group by 된 결과를 기대값으로 생성하게 됩니다.
					<pre><code class="json">{
  ...
        "groupBy": [
          "customerNumber",
          "payments.paymentDate(by=ym, format=%Y-%m)"
        ],
  ...
}					</code></pre>
					위의 예 에서 보는바와 같이 group by column 이 연관 table 에 있으면 그 경로를 함께
					지정해 주어야 합니다.
					또한 이 column 이 date type 이고, 연도 또는 월별 등 특정 단위로 group by 를 
					지정 하려면 다음을 참조 하십시요.
					<table class="table">
						<tr>
							<th>by</th>
							<th>의미</th>
						</tr>
						<tr>
							<td>y</td>
							<td>
								date 값 중 연도(year) 값 만 group by 에 사용 합니다.
								이 경우 default format 은 '%Y' 로 지정 됩니다.
							</td>
						</tr>
						<tr>
							<td>ym</td>
							<td>
								date 값 중 연도(year) 와 월(month) 값 을 group by 에 사용 합니다.
								이 경우 default format 은 '%Y-%m' 로 지정 됩니다.
							</td>
						</tr>
						<tr>
							<td>ymd</td>
							<td>
								date 값 중 연도(year), 월(month) 및 일(date) 값 을 group by 에 사용 합니다.
								이 경우 default format 은 '%Y-%m-%d' 로 지정 됩니다.
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>orderableColumns</td>
				<td>
					api 서버에 특정 column 값 으로 정렬하는 기능이 있으면 여기서 그 column 들을 지정 하십시요.
					그러면 tg 는 해당 column 값으로 정렬된 기대값을 준비한 후, 
					observed 값과 기대값을 assert 하는 코드를 생성 할 것입니다.
					<pre><code class="json">{
  ...
        "orderableColumns": "customerName, city",
  ...
}					</code></pre>
				</td>
			</tr>
		</table>

		다음은 모두 사용된 예 입니다.
		<pre><code class="json">{
  ...
    "components": [
      {
        "for": "query",
        "name": "customerStatistics",
        "table": "customers",
        "orderableColumns": "customerName, city",
        "groupBy": [
          "customerNumber",
          "payments.paymentDate(by=ym, format=%Y-%m)"
        ],
        "paginate": true,
        "columns": 
          "customerName, city, countOfPayments(count=payments), amounts(sum=payments.amount)"
      },
      ...
    ],
  ...
}
		</code></pre>

 </div>
</div>


<div id="tg-cli" class="container">
  <div class="row">
	  <h2>tg-cli</h2>
      <p>
tg-cli 는 tg 의 command line interpreter 입니다.
설명의 편의를 위해 다음과 같은 단어와 의미를 사용 하겠습니다.
	  </p>
		<table class="table">
			<tr>
				<th>단어</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>$TGHOME</td>
				<td>
					tg 가 설치된 directory 이름.
				</td>
			</tr>
			<tr>
				<td>$WORK</td>
				<td>
					tg 로 test data 와 test code 를 생성하고 작업 할 작업 directory 이름.
				</td>
			</tr>
			<tr>
				<td>schema.json</td>
				<td>
					tg 스키마를 위한 JSON file.
				</td>
			</tr>
			<tr>
				<td>ex-schema.json</td>
				<td>
					확장 스키마를 위한 JSON file.
				</td>
			</tr>
			<tr>
				<td>api.json</td>
				<td>
					api-specification 을 위한 JSON file.
				</td>
			</tr>
			<tr>
				<td>databaseName</td>
				<td>
					database 이름을 의미 함.
				</td>
			</tr>
			<tr>
				<td>tableName</td>
				<td>
					table 이름을 의미 함.
				</td>
			</tr>
		</table>

	<div id="installation">
	  <h3>설치</h3>
      <p>
tg-cli 를 다운로드한 후, $TGHOME 에 압축 파일의 압축을 푸십시요.
사용 하시는 시스템의 PATH 환경변수에 $TGHOME/bin 을 등록 하십시요. 이것으로 tg-cli 의 설치는 완료 되었습니다.
      </p>

	</div> <!-- installation -->

	<div id="generate">
	  <h3>생성</h3>
      <p>
		가장 간단하게 tg 를 사용하는 방법 부터 설명 하겠습니다.
		지금 JDBC 가 연결 가능하고 json 파일을 만들기 귀찮으면
		기본적인 test data 만 생성하기 위해 다음과 같이 할 수 있습니다.
      </p>

	  <pre><code class="shell">
$ tg -d driverClassName -l urlForDbms -b databaseName -u userName -p password
	  </code></pre>
	  또는
	  <pre><code class="shell">
$ tg -m dbmsName -b databaseName -u userName -p password
	  </code></pre>

	  각 table 을 위한 test rows 는 default 가 100 입니다.
	  만약 이 값을 1000 으로 변경 하려면 다음과 같이 하십시요.
	  <pre><code class="shell">
$ tg -m dbmsName -b databaseName -u userName -p password -t 1000
	  </code></pre>
	  또는 단순히 DB schema 를 tg schema 로 변환 하려면 다음과 같이 하십시요.
	  <pre><code class="shell">
$ tg -m dbmsName -b databaseName -u userName -p password -s path-to-json-file
	  </code></pre>
	  
      <p>
		그러나 tg 가 test data 와 test code 를 생성 하기 위해서는 
		tg 스키마와 api 등 하나 이상의 json 파일을 필요로 합니다.
		모든 json 파일들을 다음과 같이 일일이 나열할 수도 있고,
	  </p>
	  <pre><code class="shell">
$ tg json/schema.json json/api.json
	  </code></pre>
		또는 다음과 같이 main 스키마에서 나머지를 include 할 수도 있습니다.
	  <pre><code class="shell">
$ tg json/schema.json
	  </code></pre>
	  <pre><code class="json">{
  ...
  "includeSchemas": [
    "api.json"
  ]
}
	  </code></pre>
		만약 tg-schema 를 JDBC 와 연결된 DB-schema 로 부터 직접 생성 하려면 다음과 같이 사용 하십시요.
	  <pre><code class="shell">
$ tg --driver=driverClassName --url=urlForDbms --database=databaseName --user=userName --passwd=password json/api.json
	  </code></pre>
		mysql 을 예로 든 다면, 
	  <pre><code class="shell">
$ tg --driver=com.mysql.jdbc.Driver --url=jdbc:mysql://localhost:3306/databaseName --database=databaseName --user=userName --passwd=password json/api.json
	  </code></pre>

또는 좀 더 간단히 다음과 같이 사용할 수 있습니다.
	  <pre><code class="shell">
$ tg -d com.mysql.jdbc.Driver -l jdbc:mysql://localhost:3306/databaseName -b databaseName -u userName -p password json/api.json
	  </code></pre>

사용자의 DBMS 가 tg 에서 미리 준비한 DBMS 목록에 있다면 좀 더 간단히 다음과 같이 사용할 수 있습니다.
	  <pre><code class="shell">
$ tg -m dbmsName -b databaseName -u userName -p password api.json
	  </code></pre>
		단, 이 경우에는 각 DBMS 를 위한 driver 가 사용자의 
		classpath($JAVA_HOME/jre/lib/ext) 에 존재해야 합니다.
		사용 가능한 DBMS 와 다운로드 가능한 driver 들의 위치 목록은 다음과 같습니다.
		<table class="table">
			<tr>
				<th>DNMS</th>
				<th>Driver</th>
			</tr>
			<tr>
				<td>mysql</td>
				<td><a href="https://dev.mysql.com/downloads/connector/j/">mysql driver</a></td>
			</tr>
			<tr>
				<td>mariadb</td>
				<td><a href="https://mariadb.com/kb/en/library/about-mariadb-connector-j/">mariadb driver</a></td>
			</tr>
			<tr>
				<td>oracle</td>
				<td><a href="https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html">oracle driver</a></td>
			</tr>
			<tr>
				<td>db2</td>
				<td><a href="https://www.ibm.com/support/pages/db2-jdbc-driver-versions-and-downloads">db2 driver</a></td>
			</tr>
			<tr>
				<td>mssql</td>
				<td>
					<a href="https://docs.microsoft.com/en-us/sql/connect/jdbc/microsoft-jdbc-driver-for-sql-server?view=sql-server-ver15">mssql driver</a>
				</td>
			</tr>
			<tr>
				<td>postgresql</td>
				<td><a href="https://jdbc.postgresql.org/">postgresql driver</a></td>
			</tr>
			<tr>
				<td>sqlite</td>
				<td><a href="https://bitbucket.org/xerial/sqlite-jdbc/downloads/">sqlite driver</a></td>
			</tr>
			<tr>
				<td>h2</td>
				<td><a href="http://www.h2database.com/html/cheatSheet.html">h2 driver</a></td>
			</tr>
		</table>

	  <pre><code class="shell">
$ tg -m mysql -b databaseName -u userName -p password json/api.json
	  </code></pre>
		tg 의 기능을 충분히 사용하기 위해서는 확장-schema 를 작성 해야 하는데, 
		만약 확장-schema 가 있다면 다음과 같이 이를 지정 하십시요.
	  <pre><code class="shell">
$ tg json/schema.json json/ex-schema.json json/api.json
	  </code></pre>

또는 
	  <pre><code class="shell">
$ tg -m mysql -b databaseName -u userName -p password json/ex-schema.json json/api.json
	  </code></pre>
		다음은 tg-cli 에서 사용 가능한 모든 option 들 입니다.
		<table class="table">
			<tr>
				<th width="25%">short</th>
				<th width="35%">long</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>-b <i>databaseName</i></td>
				<td>--database=<i>databaseName</i></td>
				<td>
					사용자 database 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>-c <i>categoryName</i></td>
				<td>--category=<i>categoryName</i></td>
				<td>
					JDBC 에 전달 할 category 이름을 의미 합니다.
					대부분의 DBMS 에서는 필수 항목이 아닙니다.
				</td>
			</tr>
			<tr>
				<td>-d <i>driverClassName</i></td>
				<td>--driver=<i>driverClassName</i></td>
				<td>
					JDBC 에 전달 할 driver class 이름을 의미 합니다.
					JDBC 를 사용 하는 경우, 이 항목은 필수 항목 입니다.
				</td>
			</tr>
			<tr>
				<td>-l <i>url</i></td>
				<td>--url=<i>url</i></td>
				<td>
					JDBC 에 전달 할 DBMS 의 url 주소를 의미 합니다.
					많은 경우 이 주소값에 databaseName 이 포함되어야 함을 주의 하십시요.
					JDBC 를 사용 하는 경우, 이 항목은 필수 항목 입니다.
				</td>
			</tr>
			<tr>
				<td>-m <i>dbmsName</i></td>
				<td>--dbms=<i>dbmsName</i></td>
				<td>
					DBMS 이름을 의미 합니다.
					이 option 을 사용하면 -d 와 -l option 은 생략할 수 있습니다.
				</td>
			</tr>
			<tr>
				<td>-o <i>path</i></td>
				<td>--outpath=<i>path</i></td>
				<td>
					test data 와 test code 가 생성될 위치를 지정하는 option 입니다.
					default 는 현 작업 디렉토리(".") 입니다.
				</td>
			</tr>
			<tr>
				<td>-p <i>password</i></td>
				<td>--pass=<i>password</i></td>
				<td>
					JDBC 에 전달 할 password 를 의미 합니다.
					JDBC 를 사용 하는 경우, 이 항목은 필수 항목 입니다.
				</td>
			</tr>
			<tr>
				<td>-a <i>schemaName</i></td>
				<td>--schema=<i>schemaName</i></td>
				<td>
					JDBC 에 전달 할 schema 이름을 의미 합니다.
					대부분의 DBMS 에서는 필수 항목이 아닙니다.
				</td>
			</tr>
			<tr>
				<td>-u <i>userName</i></td>
				<td>--user=<i>userName</i></td>
				<td>
					JDBC 에 전달 할 username 을 의미 합니다.
					JDBC 를 사용 하는 경우, 이 항목은 필수 항목 입니다.
				</td>
			</tr>
			<tr>
				<td>-s <i>path-to-json-file</i></td>
				<td>--save=<i>path-to-json-file</i></td>
				<td>
					JDBC 에 의해 DB 스키마를 tg 스키마로 변환 한 후, 이 를 file 로 저장하는 option 입니다.
					이 option 으로 지정된 path-to-json-file 로 tg 스키마가 생성됩니다.
					이 option 이 지정되지 않으면, 생성된 tg 스키마는 test data 와 test code 생성에 사용된 후,
					file 로 저장되지 않습니다.
					<blockquote>
						지정된 path 의 file 은 존재하지 않아도 상관 없지만 directory 가 존재하지 않으면 오류가 발생 합니다.
						따라서 사용자 께서는 현재 접근 가능한 directory 를 path 로 지정해 주어야 합니다.
					</blockquote>
				</td>
			</tr>
			<tr>
				<td>-t <i>numberOfRows</i></td>
				<td>--testrows=<i>numberOfRows</i></td>
				<td>
					각 table 을 위한 test data 를 얼마나 많이 생성할 지를 결정하는 항목 입니다.
					이 항목은 test data 가 JDBC 에 의해 생성 될 때에만 유효합니다.
					이 항목은 선택 항목 이며 default 값은 100 입니다.
				</td>
			</tr>
			<tr>
				<td>-v</td>
				<td>--version</td>
				<td>
					tg 의 현 version 을 출력 합니다.
				</td>
			</tr>
			<tr>
				<td>-h</td>
				<td>--help</td>
				<td>
					도움말을 출력 합니다.
				</td>
			</tr>
		</table>

		위의 command 가 정상종료 하면 tg-cli 는 $WORK/databaseName/ 밑에 node.js 
		응용 프로그램 소스코드를 생성 하며 생성된 소스코드의 구조및 의미는 다음과 같습니다.
<ul>
  <li>app.js
    <p>
  node.js 응용 프로그램의 시작 포인트 입니다.
	</p>
  </li>
  <li>package.json
    <p>
  node.js 의 의존성 해결을 위한 환경설정 파일 입니다.
	</p>
  </li>
  <li>mk-mysql.js
    <p>
  csv/*.csv 로 부터 MySQL 용 test database 를 생성하기 위한 스크립트 입니다.
	</p>
  </li>
  <li>mk-mongodb.js
    <p>
  csv/*.csv 로 부터 mongoDB 용 test database 를 생성하기 위한 스크립트 입니다.
	</p>
  </li>
  <li>csv/
    <p>
		이 directory 안에는 스키마의 모든 table 을 위한 csv 파일이 test data 와 함께 저장되어 있습니다.
	</p>
  </li>
  <li>openapi/openapi.yaml
    <p>
		API 서버를 위한 Open API Specification 3.0 파일 입니다.
	</p>
  </li>
  <li>test/
    <ul>
      <li>expects/test_conditions.json
        <p>
      api 서버의 test 를 위한 모든 기대값들을 저장 한 JSON 파일 입니다.
	    </p>
      </li>
      <li>find/tableName.js
        <p>
			특정 table 의 find api 를 test 하는 code 들이 저장되어 있습니다.
	    </p>
      </li>
      <li>query/tableName.js
        <p>
			특정 table 의 query api 를 test 하는 code 들이 저장되어 있습니다.
	    </p>
      </li>
	</ul>
  </li>
  <li>mutable-test/tableName.js
    <p>
		이 디렉토리 밑의 tableName.js 는 table 을 위한 mutable api 의 test code 입니다.
	</p>
  </li>
</ul>
	</div> <!-- generate -->

	<div id="initialize">
	  <h3>초기화</h3>
      <p>
먼저 $WORK/databaseName/ directory 로 이동 하십시요.
그다음, node.js app 의 의존성 해소를 위해 다음의 명령을 사용 하십시요.
      </p>
	  <pre><code class="shell">
$ npm install
	  </code></pre>
이 과정이 정상 종료 하면, 이제 tg-cli 가 생성한 기능들을 사용할 준비가 되었습니다.

	</div> <!-- initialize -->

	<div id="gen-test-database">
	  <h3>test database 생성</h3>
      <p>
tg-cli 가 준비한 test data 는 csv 형식으로 직접 이용할 수는 없고, 각 DBMS 에 맞게 스크립트를 작성해야 합니다.
tg-cli 는 MySQL 용 과 mongoDB 용 스크립트를 준비 했습니다. 만약 사용자의 DBMS 가 이 둘 중 하나가 아니라면 
mk-mysql.js 또는 mk-mk-mongodb.js 를 참조하여 직접 스크립트를 작성해야 합니다.
여기서는 MySQL 을 사용 한다고 가정하고 설명을 진행 하겠습니다.
MySQL 용 test database 의 생성을 위해 다음의 명령을 사용 하십시요.
      </p>

	  <pre><code class="shell">
$ npm run gen-mysql -- testDatabaseName username password
	  </code></pre>
		testDatabaseName 은 test data 가 저장될 database 이름으로서 이 명령의 사용 전
		DB 스키마에 의해 table 들이 미리 생성되어 있어야 합니다.
		<blockquote>
			<b>주의:</b> 이 명령에 의해 지정된 이름의 database 는 완전 초기화 되며, 이 전 저장된 data 들은 모두 삭제 되므로
			사용자께서는 이 점을 충분히 인지하고 있어야 합니다.
		</blockquote>

다음은 exproj_test 라는 database 와 ray 라는 username, 그리고 1234567 을 password 로 사용하는 예 입니다.
	  <pre><code class="shell">
$ npm run gen-mysql -- exproj_test ray 1234567
	  </code></pre>
	</div> <!-- gen-test-database -->

	<div id="run-api-server">
	  <h3>api 서버 준비</h3>
      <p>
api 서버의 test 를 위해 api 서버를 api specification 에서 지정된 IP 주소에서 실행 시켜야 합니다.
이 때, 반드시 앞에서 우리가 생성한 test database 가 api 서버의 access 대상이 되도록 설정 해야 합니다.
      </p>
	</div> <!-- run-api-server -->

	<div id="find-and-query-test">
	  <h3>find and query api test</h3>
      <p>
모든 find api 와 query api 의 test 를 위해 $WORK/databaseName/ 에서 다음 명령을 사용 하십시요.
      </p>
	  <pre><code class="shell">
$ npm test
	  </code></pre>
		이 명령은 api-specification 에서 지정된 api 중 find 와 query api 에 대해 
		준비된 test pattern 으로 request 를 보낸 후,  
		response data 를 미리 준비한 기대값과 비교하고 그 결과를 report 할 것입니다.
<br/><br/>
	  전체 api 가 아닌 특정 api 만 test 하려면 다음과 같이 사용 하십시요.
	  <pre><code class="shell">
$ npm test -- --grep "string in it('...') in test javascript files."
	  </code></pre>
	  위의 예 에서 --grep 다음의 string 은 find 또는 query api test 를 위한 javascript file 에서 각 api test 를 위한
	  it('...') 에 사용된 string 을 의미 합니다.
	  <pre><code class="javascript">
describe('query test to table customer...', () =&gt; {
  it('test to /customers/list with column for city', (done) =&gt; {
    ...
  }
  ...
}
	  </code></pre>

	</div> <!-- find-and-query-test -->

	<div id="mutable-test">
	  <h3>mutable api test</h3>
      <p>
mutable test 는 DB 의 상태를 변화 시킵니다. 따라서 mutable test 이 후에는 find api test 나 query api test 는 신뢰할 수 없습니다.
그러므로 find test 와 query test 가 완전히 종료한 후, mutable test 를 수행 하십시요.
만약 mutable test 이 후, find test 나 query test 가 필요해지는 상황이 온다면, 생성된 test data 를 이용하여 test database 를 다시 한번 초기화 한 후, 수행 하십시요.
<br/><br/>
mutable api 의 test 를 위해 $WORK/databaseName/ 에서 다음 명령을 사용 하십시요.
      </p>
	  <pre><code class="shell">
$ npm run mutable-test
	  </code></pre>
		이 명령은 mutable api url 에 대해 준비된 test pattern 으로 request 를 보냅니다.
		그 다음 response 가 성공인지 확인한 후, 
		준비된 기대값 상태와 api 서버의 DB 의 상태를 비교하고 그 결과를 report 할 것입니다.
	</div> <!-- mutable-test -->
<br/><br/>
	  여기서도 전체 api 가 아닌 특정 api 만 test 하려면 다음과 같이 사용 하십시요.
	  <pre><code class="shell">
$ npm run mutable-test -- --grep "string in it('...') in test javascript files."
	  </code></pre>
  </div>
</div>

<div id="tg-schema" class="container">
  <div class="row">
    <h2>tg 스키마</h2>
    <p>
		tg 스키마는 DB 스키마의 JSON 표현 입니다.
	</p>
  </div>
</div>

<div id="table" class="container">
  <div class="row">
    <h2>table</h2>
    <p>
		각 table 은 elements 안에서 정의 되며 다음과 같은 구성요소를 갖고 있습니다.
	</p>
		<table class="table">
			<tr>
				<th>속성</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>table</td>
				<td>Table 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>properties</td>
				<td>
					이 속성은 배열로서 하나 이상의 Column 또는 Object 또는 Array 가 올 수 있습니다.
					Column 에 대해서는 <a href="#column">여기</a> 를 참조 하십시요.
				</td>
			</tr>
			<tr>
				<td>primaryKey</td>
				<td>
					Table 의 primary key 를 지정 합니다.
					여기에는 다음과 같은 속성들이 있습니다.
					<table class="table">
						<tr>
							<th>속성</th>
							<th>의미</th>
						</tr>
						<tr>
							<td>columns</td>
							<td>
								이 속성에 primary key 에 해당하는 column 이름들을 콤마로 구분하여 나열 하십시요.
							</td>
						</tr>
						<tr>
							<td>from</td>
							<td>
								primary key column 값을 어디서 만드는지를 의미 합니다.
								이 속성의 값이 'dbms' 이면, DBMS 가 primary key 값을 생성 하고,
								'user' 이면 사용자가 primary key 값을 입력 합니다.
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>uniqueKeys</td>
				<td>
					이 속성의 값은 배열로서 배열의 각 원소에는 unique key 에 해당하는 column 이름들을 콤마로 구분하여 나열 하십시요.
				</td>
			</tr>
			<tr>
				<td>manyToOnes</td>
				<td>
					여기서 하나 이상의 <a href="#many-to-one">many-to-one</a> 관계를 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>oneToManies</td>
				<td>
					여기서 하나 이상의 <a href="#one-to-many">one-to-many</a> 관계를 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>manyToManies</td>
				<td>
					여기서 하나 이상의 <a href="#many-to-many">many-to-many</a> 관계를 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>oneToOnes</td>
				<td>
					여기서 하나 이상의 <a href="#one-to-one">one-to-one</a> 관계를 지정 하십시요.
				</td>
			</tr>
		</table>
		<pre><code class="json">{
  ...
  "elements": [
    {
      "table": "customers",
      "properties": [
         { "column": "id", "datatype": "int", "autoIncrement": true },
         { "column": "customerName", "datatype": "string(255)" },
         { "column": "salesRepEmployeeNumber", "datatype": "int", "required": false },
        ...
      ],
      "primaryKey": { "columns": "id", "from": "dbms" },
      "manyToOnes": [
        { "table": "employees", "join": "salesRepEmployeeNumber = employeeNumber" }
      ],
      "oneToManies": [
        { "table": "orders", "join": "id = customer_id" },
        { "table": "payments", "join": "id = customer_id" }
      ],
    },
    {
      "table": "products",
      "properties": [
        { "column": "id", "datatype": "int", "autoIncrement": true },
        ...
      ],
      "primaryKey": { "columns": "id", "from": "dbms" },
      "manyToManies": [
        { "table": "tags", "joinTable": "product_tags" }
      ],
      ...
    }
  ],
  ...
}
		</code></pre>
  </div>
</div>

<div id="object" class="container">
  <div class="row">
    <h2>object</h2>
    <p>
		Table 과 object 의 차이는 key columns(primary key 와 unique key) 와 관계의 존재 유무 입니다.
		Table 에는 key columns 와 관계가 존재 하지만, object 에는 존재하지 않습니다.
		각 object 는 elements 안에서 정의 되며 다음과 같은 구성요소를 갖고 있습니다.
	</p>
		<table class="table">
			<tr>
				<th>속성</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>object</td>
				<td>
					object 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>properties</td>
				<td>
					Table 의 properties 와 같습니다.
					<a href="#table">여기</a> 를 참조 하십시요.
				</td>
			</tr>
		</table>
		<pre><code class="json">{
  ...
  "elements": [
    {
      "object": "Image",
      "properties": [
        {"column": "url", "datatype": "string"},
        {"column": "width", "datatype": "int"},
        {"column": "height", "datatype": "int"}
      ]
    },
    {
      "table": "AchievementType", 
      "properties": [
        {"column": "id", "datatype": "string"},
        ...
        {"array": "images", "datatype": "Image"},
        ...
        {"object": "application", "datatype": "ApplicationReference"},
		...
      ],
      "primaryKey": {"columns": "id", "from": "dbms"},
    },
    ...
  ],
  ...
}
		</code></pre>
  </div>
</div>

<div id="column" class="container">
  <div class="row">
    <h2>Column</h2>
    <p>
		각 column 들은 table 의 properties 안에서 정의 되며 다음과 같은 구성요소를 갖고 있습니다.
	</p>
	<table class="table">
		<tr>
			<th>속성</th>
			<th>의미</th>
		</tr>
		<tr>
			<td>column</td>
			<td>
				column 이름을 의미 합니다.
			</td>
		</tr>
		<tr>
			<td>datatype</td>
			<td>
				column 의 datatype 을 지정 합니다.
				지정 가능한 datatype 은 다음과 같습니다.
				<table class="table">
				<tr>
					<th>datatype</th>
					<th>size</th>
					<th>scale</th>
				</tr>
				<tr>
					<td>string, text, binary</td>
					<td>Y</td>
					<td>N</td>
				</tr>
				<tr>
					<td>decimal, number</td>
					<td>Y</td>
					<td>Y</td>
				</tr>
				<tr>
					<td>
					double, float, real, int, int8, int16, int32, int64, tiny, short, 
					bigint, long, date, timestamp, time
					</td>
					<td>N</td>
					<td>N</td>
				</tr>
				</table>
			</td>
		</tr>
		<tr>
			<td>required</td>
			<td>
				이 column 이 null 값을 가질 수 있는지 여부를 지정 합니다.
				이 속성값이 true 이면 not null, false 이면 null 을 가질 수 있습니다.
			</td>
		</tr>
		<tr>
			<td>values</td>
			<td>
				이 column 이 가질 수 있는 값이 한정되어 있는 경우, 그 값들 모두를 콤마로 구분하여 이 속성값으로 지정 합니다.
			</td>
		</tr>
		<tr>
			<td>min</td>
			<td>
				이 column 이 가질수 있는 최소 값을 지정 합니다.
			</td>
		</tr>
		<tr>
			<td>max</td>
			<td>
				이 column 이 가질수 있는 최대 값을 지정 합니다.
			</td>
		</tr>
	</table>
		<pre><code class="json">{
  ...
  "elements": [
    ...
    {
      "table": "products",
      "properties": [
        { "column": "id", "datatype": "int", "autoIncrement": true },
        { "column": "name", "datatype": "string(255)" },
        { "column": "base_price", "datatype": "number(8,3)" },
        { "column": "orderable_qty", "datatype": "int", "min": 1, "max": 100 },
        { "column": "comment", "datatype": "text", "required": false },
        { "column": "state", "datatype": "string(255)", "values": "Bad, Not bad, Good" },
        ...
      ],
      ...
    }
  ],
  ...
}
		</code></pre>
  </div>
</div>

<div id="many-to-one" class="container">
  <div class="row">
    <h2>many-to-one</h2>
    <p>
		m 대 1 관계의 table 들을 여기에 나열 합니다. 각 manyToOne 관계는 다음과 같은 속성들을 가질 수 있습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>table</td>
	    <td>
			m 대 1 관계에서 m 에 해당하는 table 이름을 의미 합니다.
			두 table 은 경우에 따라 같은 table 일 수도 있습니다.
		</td>
	  </tr>
	  <tr>
	    <td>as</td>
	    <td>
			manyToOne 관계의 table 이름이 어떤 이유로 적당하지 않을 수 있습니다.
			예를들어, 동일한 table 에 대해 하나 이상의 관계가 있는 경우 또는 다른 column 이름과 중복되는 경우 또는
			단순히 이름이 너무 길거나 마음에 들지 않을 수 있습니다.
			이런경우 다른 이름으로 변경할 수 있는데, 이 속성 값에 그 변경된 이름을 지정 하십시요.
		</td>
	  </tr>
	  <tr>
	    <td>join</td>
	    <td>
			이 속성은 관계를 형성하는 두 table 들이 어떤 column(s) 값으로 연결 되는지를 의미 합니다.
			두 column 이름은 '=' 기호로 연결 되는데, 좌측이 현 table column 이고, 우측이 상대 table column 입니다.
			만약 이 연결이 하나 이상의 column 값들로 연결된다면, 각각의 연결을 콤마로 구분하여 지정 하십시요.
			(Currently, composite keys to join is not supported)
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "manyToOnes": [
     { "table": "employees", "as": "sellers", "join": "salesRepEmployeeNumber = employeeNumber" }
   ],
}
	</code></pre>
  </div>
</div>

<div id="one-to-many" class="container">
  <div class="row">
    <h2>one-to-many</h2>
    <p>
		1 대 m 관계의 table 들을 여기에 나열 합니다. 각 oneToMany 관계는 다음과 같은 속성들을 가질 수 있습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>table</td>
	    <td>
			1 대 m 관계에서 m 에 해당하는 table 이름을 의미 합니다.
			두 table 은 경우에 따라 같은 table 일 수도 있습니다.
		</td>
	  </tr>
	  <tr>
	    <td>as</td>
	    <td>
			manyToOnes 의 as 속성과 동일 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>join</td>
	    <td>
			manyToOnes 의 join 속성과 동일 합니다.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "oneToManies": [
     { "table": "employees", "as":"office_employees", "join": "id = office_id" }
   ],
}
	</code></pre>
  </div>
</div>

<div id="many-to-many" class="container">
  <div class="row">
    <h2>many-to-many</h2>
    <p>
		m 대 m 관계의 table 들을 여기서 지정 합니다.
		여기에는 다음과 같은 속성들이 있습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>table</td>
	    <td>
			m 대 m 관계에서 m 에 해당하는 table 이름을 의미 합니다.
			두 table 은 경우에 따라 같은 table 일 수도 있습니다.
		</td>
	  </tr>
	  <tr>
	    <td>as</td>
	    <td>
			manyToOnes 의 as 속성과 동일 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>joinTable</td>
	    <td>
			many-to-many 관계 에서는 두 table 을 연결해 주는 join table 이 필요 합니다.
			여기서 join table 이름을 지정 하십시요.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
 "elements": [
    {
      "table": "users",
      "properties": [
        { "column": "id", "datatype": "int", "autoIncrement": true },
        ...
      ],
      ...
      "manyToManies": [
        { "table": "users", "as": "friends", "joinTable": "user_friends" }
      ]
    },
    {
      "table": "user_friends",
      "properties": [
        { "column": "user_id", "datatype": "int" },
        { "column": "friend_id", "datatype": "int" },
        ...
      ],
      ...
      "manyToOnes": [
        { "table": "users", "join": "user_id = id" },
        { "table": "users", "as": "friends", "join": "friend_id = id" }
      ]
    },
    ...
  ]
}
	</code></pre>
	<blockquote>
		같은 table 을 many-to-many table 로 지정할 때, as 를 사용하여 고유의 이름을 지정해 주어야 합니다.
		이것은 joinTable 에서도 마찬가지가 되는데, 이 때, joinTable 에서도 동일한 두 table 을 many-to-one
		관계로 지정해야 하며 따라서 여기서도 as 가 필요하게 됩니다. 이 경우, 두 table 의 as 를 같은 이름으로 사용 하셔야 합니다.
		(See '"as": "friends"' in above example)
	</blockquote>
  </div>
</div>

<div id="one-to-one" class="container">
  <div class="row">
    <h2>one-to-one</h2>
    <p>
		1 대 1 관계의 table 들을 여기에 나열 합니다. 각 oneToOne 관계는 다음과 같은 속성들을 가질 수 있습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>table</td>
	    <td>
			1 대 1 관계의 table 이름을 의미 합니다.
			두 table 은 경우에 따라 같은 table 일 수도 있습니다.
		</td>
	  </tr>
	  <tr>
	    <td>as</td>
	    <td>
			manyToOnes 의 as 속성과 동일 합니다.
		</td>
	  </tr>
	  <tr>
	    <td>join</td>
	    <td>
			manyToOnes 의 join 속성과 동일 합니다.
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "oneToOnes": [
     { "table": "employees_stuff", "join": "id = employee_id" }
   ],
}
	</code></pre>
  </div>
</div>

<div id="ex-schema" class="container">
  <div class="row">
    <h2>스키마 확장</h2>
    <p>
		스키마 확장은 DB 스키마 에서 제공하지 않는 정보들을 tg 스키마에 추가하는 작업 입니다.
		이 확장 정보들을 tg 스키마 파일에 함께 제공해도 되지만,
		DB 스키마의 변동 가능성을 고려 해서, 스키마 확장은 별도의 json 파일로 작성 하기를 강력히 권장 합니다.
		RDB 를 사용하는 사용자라면 tg 스키마를 JDBC 로 부터 추출할 수 있으므로, 
		사용자는 스키마 확장과 api specification 만 작성하면 tg 를 사용할 수 있습니다.
	</p>

    <h3>includeSchemas</h3>
	<p>
		큰 스키마를 하나의 파일에 저장하는것은 좋은 생각이 아닙니다.
		이런 불편을 해소하기 위해 스키마를 하나 이상의 JSON 파일로 만든 후, 이들을 main 스키마 파일에서
		include 할 수 있는데, 이 속성은 그런 경우를 위한 것 입니다.
		이 속성에 배열을 지정 하고, 배열의 각 원소에는 외부 스키마 파일 이름을 지정 하십시요.
		각 파일의 경로는 main 스키마 파일이 있는 위치에 있다고 가정 합니다.
		만약 이 파일들이 main 스키마가 있는 위치에 있지 않다면 그 상대 경로를 모두 지정해 주어야 합니다.
	</p>
	<pre><code class="json">{
  ...
  "includeSchemas": [
    "products.json",
    "options/product_options.json",
    ...
  ],
  ...
}
	</code></pre>

    <h3>authentications</h3>
	<p>
		api 에 따라서는 인가된 사용자들만 접근이 허용된 경우도 있습니다.
		이런 경우를 위해 인증 table 관련 정보를 이 속성을 통해 알려 주셔야 합니다.
		이 속성에 대한 값은 배열로 하나 이상의 인증 table 관련 정보를 지정할 수 있으며, 
		각 원소는 다음과 같은 속성을 가질 수 있습니다.				
		<table class="table">
			<tr>
				<th>속성</th>
				<th>의미</th>
			</tr>
			<tr>
				<td>table</td>
				<td>인증 table 을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>username</td>
				<td>
					인증 table 에서 username 에 해당하는 column 의 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>password</td>
				<td>
					인증 table 에서 password 에 해당하는 column 의 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>passwordHash</td>
				<td>
					password 가 어떤 암호 알고리즘으로 암호화 되는지 지정 하십시요. 
					허용 가능한 값들은 다음과 같습니다.
					<ul>
					<li>md5</li>
					<li>sha</li>
					<li>sha256</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>role</td>
				<td>
					인증 table 에 권한 column 이 따로 없고,
					권한 table 도 따로 존재하지 않지만 각 인증 table 로 인증한
					사용자에게 고유의 권한을 주고 싶다면 이 속성으로 그 권한을 지정 하십시요.
				</td>
			</tr>
			<tr>
				<td>authority</td>
				<td>
					이 속성은 인증 table 또는 권한 table 에서 authority column 의 이름을 의미 합니다.
				</td>
			</tr>
			<tr>
				<td>authorityTable</td>
				<td>
					권한 table 이 따로 존재하는 경우, 해당 권한 table 이름을 이 속성으로 지정 하십시요.
				</td>
			</tr>
		</table>
	</p>

	<pre><code class="json">{
  ...
  "authentications": [
    {
      "table": "customers",
      "username": "email",
      "password": "password",
      "passwordHash": "sha256",
      "role": "ROLE_CUSTOMER"
    },
    {
      "table": "employees",
      "username": "email",
      "password": "password",
      "passwordHash": "sha256",
      "role": "ROLE_EMPLOYEE"
    },
    {
      "table": "users",
      "username": "email",
      "password": "password",
      "passwordHash": "sha256",
      "authority": "authority"
    }
  ...
}
	</code></pre>

    <h3>global testRows 지정</h3>
    <p>
		이것은 table 을 위한 test data 를 얼마나 많이 생성 할 것인지 전역적으로 지정하는 속성 입니다.
		만약 table 을 위한 test data 를 얼마나 많이 생성 해야 하는지 지정하지 않았다면
		여기서 지정한 방식이 default 로 적용 됩니다.
	</p>
	<pre><code class="json">{
   ...
   testRows: 100,
   ...
   "elements": [
     { 
       "table": "users",
       ...
     },
     ...
   ],
}
	</code></pre>

    <h3>table testRows 지정</h3>
    <p>
		table 을 위한 testdata 를 얼마나 많이 생성해야 하는지 이 속성으로 지정할 수 있습니다.
	</p>
	<pre><code class="json">{
   ...
   "elements": [
     { "alter": "users", "testRows": 100 }
     },
     ...
   ],
}
	</code></pre>

    <h3>관계 확장</h3>
    <p>
		여기서 table 에 <a href="#many-to-many">many-to-many</a> 와 같은 관계를 추가할 수 있습니다.
		그리고 이미 설정된 관계의 as(alias) 를 지정 하거나 수정할 수 있습니다.
		특히 이미 as 가 지정된 관계의 as 를 수정하려 할 때에는 기존의 as 를 관계 table 에 지정해 주어야 합니다.
		예를들어 users table 에 users2 로 as(alias) 된 many-to-many 관계의 as 값을
	</p>
	<pre><code class="json">{
   "elements": [
     { "table": "users", 
       "manyToManies" [
         { "table": "users", "as": "users2", "joinTable": "user_friends" },
         ...
       ]
     },
   ],
}
	</code></pre>

	friends 로 수정하려 한다면, 다음과 같이 하십시요.
	<pre><code class="json">{
     { "alter": "users", 
       "manyToManies" [
         { "table": "users2", "as": "friends" },
         ...
       ]
     },
   ],
}
	</code></pre>

    <h3>column 확장</h3>
    <p>
		어떤 Table column 은 아무 값이나 가지면 안되고 특정 규칙에 의한 값만 가져야 합니다.
		여기에서 column 의 값을 조절하는 방법에 대해 알아 보겠습니다.
	</p>
	<table class="table">
	  <tr>
	    <th>속성</th>
	    <th>의미</th>
	  </tr>
	  <tr>
	    <td>pattern</td>
	    <td>
			이 속성은 column 이 가져야 할 값의 패턴을 Perl 정규식으로 지정 합니다.
			<pre><code class="json">{
  { "column": "social_number", "pattern": "\d{6}-\d{7}" },
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>min, max</td>
	    <td>
			column 이 가져야 할 값의 최소값 또는 최대값을 이 속성값으로 지정 하십시요.
			<pre><code class="json">{
  { "column": "price", "min": 100 },
  { "column": "service_fee", "max": 1000 },
  { "column": "price", "min": 100, "max": 1000 }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>관계</td>
	    <td>
			column 이 가져야 할 값이 특정 상수 값이나 다른 table column 값과 어떤 관계를 가져야 하는 경우
			이를 여기서 지정 하십시요. 지정 가능한 관계는 'eq', 'ne', 'gt', 'ge', 'lt', 'le' 입니다.
			<pre><code class="json">{
  { "column": "price", "attrs": "eq=table.column" },
  { "column": "shipping_date", "attrs": "gt=orders.order_date" }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>first_name, last_name, full_name</td>
	    <td>
			column 값이 first_name, last_name 또는 full_name 을 의미할 때 attrs 속성에 이를 지정 합니다.
			<pre><code class="json">{
  { "column": "firstName", "attrs": "first_name" },
  { "column": "lastName", "attrs": "last_name" },
  { "column": "name", "attrs": "full_name" }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>country, city, state, street, zipcode, address</td>
	    <td>
			column 값이 주소를 의미할 때 지정 합니다.
			<pre><code class="json">{
  { "column": "country", "attrs": "country" },
  { "column": "city", "attrs": "city" },
  { "column": "address", "attrs": "address" }
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>words, sentence for String</td>
	    <td>
		  column 값이 임의의 단어 나열 또는 문장을 의미할 때 지정 합니다.
		  words 는 임의의 단어 나열 이므로 전체 문장이 의미가 없고, 속도가 sentence 보다 약간 빠릅니다.
			<pre><code class="json">{
  { "column": "comment", "attrs": "words" },
  { "column": "description", "attrs": "sentence" },
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>words, sentences for Text</td>
	    <td>
		  column 의 datatype 이 text type 인 경우, words 또는 sentences 를 지정할 수 있습니다.
		  이 경우, 단어들 또는 문장들이 test data 로 생성되며, 그렇지 않은 경우에는 random number 가 test data 로
		  생성 됩니다.
			<pre><code class="json">{
  { "column": "comment", "attrs": "words" },
  { "column": "description", "attrs": "sentence" },
}
			</code></pre>
		</td>
	  </tr>
	  <tr>
	    <td>faker</td>
	    <td>
			<a href="https://github.com/faker-ruby/faker">Faker</a> package 를 사용 합니다.
			만약 Faker package 의 Faker::Address.city method 를 사용하고 싶으면 다음과 같이 하십시요.
			<pre><code class="json">{
  { "column": "city", "attrs": "faker=Address.city" },
}
			</code></pre>
		</td>
	  </tr>
	</table>
	<pre><code class="json">{
   "elements": [
     { "alter": "customers", 
       "columns" [
         { "column": "first_name", "attrs": "first_name" },
         { "column": "last_name", "attrs": "last_name" }
       ]
     },
     { "alter": "orders", 
       "columns" [
         { "column": "shipping_date", "attrs": "gt=order_date" },
         { "column": "address", "attrs": "address" }
       ]
     },
     { "alter": "payments", 
       "columns" [
         { "column": "payment_date", "attrs": "gt=orders.order_date" },
         { "column": "credit_card", "pattern": "\d{4}-\d{4}-\d{4}-\d{4}" }
       ]
     }
   ],
}
	</code></pre>
  </div>
</div>

<div id="fixed-testdata" class="container">
  <div class="row">
    <h2>고정된 testdata</h2>
    <p>
		특정 Table, 예를들어 국가명 table 이나 시도명 table 과 같이 
		test data 가 임의로 생성 되어서는 안되고, 특정 값들로 지정 되어야 하는 경우가 있습니다.
		이런 testdata 를 지정 하려면 'testdata' 속성을 사용 하십시요.
		여기서 columns 로 지정된 column 수 와 values 의 각 value 수는 정확히 일치해야 합니다.
	</p>
	
	<pre><code class="json">{
   "elements": [
     { "table": "states", 
       "testdata" {
         "columns" "id, name",
         "values": [
           [1, "강원"],
           [2, "경기"],
           [3, "충남"],
           [4, "충북"],
           [5, "전북"],
           [6, "경북"],
           [7, "전남"],
           [8, "경남"],
           [9, "제주"]
         ]
       }
     },
   ],
}
	</code></pre>
	<blockquote>
	<b>주의:</b> 
		test data 의 primary key 값은 1 부터 순차적으로 증가하는 번호로 지정 되어야 합니다.
		만약 primary key column 의 datatype 이 string 이라면 "1", "2" 등 으로 지정 하십시요.
	</blockquote>
  </div>
</div>

</div> <!-- end of content-->

<div id="rightbar">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- tg-ad-display -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2723563477834102"
     data-ad-slot="6271003885"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

</div> <!-- end of wrapper-->

<div class="footer">
  <div class="row">
    <p>
	  Copyright &copy; 2019 ~ 2020 by GGoons.
	</p>
  </div>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="/js/tg.js"></script>

</body>
</html>
